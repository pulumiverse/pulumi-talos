# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BootstrapTimeoutsArgs',
    'BootstrapTimeoutsArgsDict',
    'ConfigurationApplyOnDestroyArgs',
    'ConfigurationApplyOnDestroyArgsDict',
    'TimeoutArgs',
    'TimeoutArgsDict',
    'CertificateArgs',
    'CertificateArgsDict',
    'CertificatesArgs',
    'CertificatesArgsDict',
    'CertificatesArgs',
    'CertificatesArgsDict',
    'CertificateArgs',
    'CertificateArgsDict',
    'ClientConfigurationArgs',
    'ClientConfigurationArgsDict',
    'ClusterArgs',
    'ClusterArgsDict',
    'ClusterArgs',
    'ClusterArgsDict',
    'KeyArgs',
    'KeyArgsDict',
    'KeyArgs',
    'KeyArgsDict',
    'KubernetesSecretsArgs',
    'KubernetesSecretsArgsDict',
    'KubernetesSecretsArgs',
    'KubernetesSecretsArgsDict',
    'MachineSecretsArgs',
    'MachineSecretsArgsDict',
    'MachineSecretsArgs',
    'MachineSecretsArgsDict',
    'TrustdInfoArgs',
    'TrustdInfoArgsDict',
    'TrustdInfoArgs',
    'TrustdInfoArgsDict',
    'GetDisksClientConfigurationArgs',
    'GetDisksClientConfigurationArgsDict',
    'GetDisksTimeoutsArgs',
    'GetDisksTimeoutsArgsDict',
]

MYPY = False

if not MYPY:
    class BootstrapTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    BootstrapTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BootstrapTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)


if not MYPY:
    class ConfigurationApplyOnDestroyArgsDict(TypedDict):
        graceful: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Graceful indicates whether node should leave etcd before the upgrade, it also enforces etcd checks before leaving. Default true
        """
        reboot: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reboot indicates whether node should reboot or halt after resetting. Default false
        """
        reset: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Reset the machine to the initial state (STATE and EPHEMERAL will be wiped). Default false
        """
elif False:
    ConfigurationApplyOnDestroyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigurationApplyOnDestroyArgs:
    def __init__(__self__, *,
                 graceful: Optional[pulumi.Input[_builtins.bool]] = None,
                 reboot: Optional[pulumi.Input[_builtins.bool]] = None,
                 reset: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] graceful: Graceful indicates whether node should leave etcd before the upgrade, it also enforces etcd checks before leaving. Default true
        :param pulumi.Input[_builtins.bool] reboot: Reboot indicates whether node should reboot or halt after resetting. Default false
        :param pulumi.Input[_builtins.bool] reset: Reset the machine to the initial state (STATE and EPHEMERAL will be wiped). Default false
        """
        if graceful is not None:
            pulumi.set(__self__, "graceful", graceful)
        if reboot is not None:
            pulumi.set(__self__, "reboot", reboot)
        if reset is not None:
            pulumi.set(__self__, "reset", reset)

    @_builtins.property
    @pulumi.getter
    def graceful(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Graceful indicates whether node should leave etcd before the upgrade, it also enforces etcd checks before leaving. Default true
        """
        return pulumi.get(self, "graceful")

    @graceful.setter
    def graceful(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "graceful", value)

    @_builtins.property
    @pulumi.getter
    def reboot(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reboot indicates whether node should reboot or halt after resetting. Default false
        """
        return pulumi.get(self, "reboot")

    @reboot.setter
    def reboot(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reboot", value)

    @_builtins.property
    @pulumi.getter
    def reset(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Reset the machine to the initial state (STATE and EPHEMERAL will be wiped). Default false
        """
        return pulumi.get(self, "reset")

    @reset.setter
    def reset(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "reset", value)


if not MYPY:
    class TimeoutArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    TimeoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimeoutArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class CertificateArgsDict(TypedDict):
        """
        A Machine Secrets Certificate
        """
        cert: _builtins.str
        """
        Certificate
        """
        key: _builtins.str
        """
        Private Key
        """
elif False:
    CertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateArgs:
    def __init__(__self__, *,
                 cert: _builtins.str,
                 key: _builtins.str):
        """
        A Machine Secrets Certificate
        :param _builtins.str cert: Certificate
        :param _builtins.str key: Private Key
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        """
        Certificate
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: _builtins.str):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Private Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)


if not MYPY:
    class CertificatesArgsDict(TypedDict):
        """
        A complete Machine Secrets Certificates configuration
        """
        etcd: 'CertificateArgsDict'
        k8s: 'CertificateArgsDict'
        k8s_aggregator: 'CertificateArgsDict'
        k8s_serviceaccount: 'KeyArgsDict'
        os: 'CertificateArgsDict'
elif False:
    CertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatesArgs:
    def __init__(__self__, *,
                 etcd: 'CertificateArgs',
                 k8s: 'CertificateArgs',
                 k8s_aggregator: 'CertificateArgs',
                 k8s_serviceaccount: 'KeyArgs',
                 os: 'CertificateArgs'):
        """
        A complete Machine Secrets Certificates configuration
        """
        pulumi.set(__self__, "etcd", etcd)
        pulumi.set(__self__, "k8s", k8s)
        pulumi.set(__self__, "k8s_aggregator", k8s_aggregator)
        pulumi.set(__self__, "k8s_serviceaccount", k8s_serviceaccount)
        pulumi.set(__self__, "os", os)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> 'CertificateArgs':
        return pulumi.get(self, "etcd")

    @etcd.setter
    def etcd(self, value: 'CertificateArgs'):
        pulumi.set(self, "etcd", value)

    @_builtins.property
    @pulumi.getter
    def k8s(self) -> 'CertificateArgs':
        return pulumi.get(self, "k8s")

    @k8s.setter
    def k8s(self, value: 'CertificateArgs'):
        pulumi.set(self, "k8s", value)

    @_builtins.property
    @pulumi.getter(name="k8sAggregator")
    def k8s_aggregator(self) -> 'CertificateArgs':
        return pulumi.get(self, "k8s_aggregator")

    @k8s_aggregator.setter
    def k8s_aggregator(self, value: 'CertificateArgs'):
        pulumi.set(self, "k8s_aggregator", value)

    @_builtins.property
    @pulumi.getter(name="k8sServiceaccount")
    def k8s_serviceaccount(self) -> 'KeyArgs':
        return pulumi.get(self, "k8s_serviceaccount")

    @k8s_serviceaccount.setter
    def k8s_serviceaccount(self, value: 'KeyArgs'):
        pulumi.set(self, "k8s_serviceaccount", value)

    @_builtins.property
    @pulumi.getter
    def os(self) -> 'CertificateArgs':
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: 'CertificateArgs'):
        pulumi.set(self, "os", value)


if not MYPY:
    class CertificatesArgsDict(TypedDict):
        """
        A complete Machine Secrets Certificates configuration
        """
        etcd: pulumi.Input['CertificateArgsDict']
        k8s: pulumi.Input['CertificateArgsDict']
        k8s_aggregator: pulumi.Input['CertificateArgsDict']
        k8s_serviceaccount: pulumi.Input['KeyArgsDict']
        os: pulumi.Input['CertificateArgsDict']
elif False:
    CertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificatesArgs:
    def __init__(__self__, *,
                 etcd: pulumi.Input['CertificateArgs'],
                 k8s: pulumi.Input['CertificateArgs'],
                 k8s_aggregator: pulumi.Input['CertificateArgs'],
                 k8s_serviceaccount: pulumi.Input['KeyArgs'],
                 os: pulumi.Input['CertificateArgs']):
        """
        A complete Machine Secrets Certificates configuration
        """
        pulumi.set(__self__, "etcd", etcd)
        pulumi.set(__self__, "k8s", k8s)
        pulumi.set(__self__, "k8s_aggregator", k8s_aggregator)
        pulumi.set(__self__, "k8s_serviceaccount", k8s_serviceaccount)
        pulumi.set(__self__, "os", os)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> pulumi.Input['CertificateArgs']:
        return pulumi.get(self, "etcd")

    @etcd.setter
    def etcd(self, value: pulumi.Input['CertificateArgs']):
        pulumi.set(self, "etcd", value)

    @_builtins.property
    @pulumi.getter
    def k8s(self) -> pulumi.Input['CertificateArgs']:
        return pulumi.get(self, "k8s")

    @k8s.setter
    def k8s(self, value: pulumi.Input['CertificateArgs']):
        pulumi.set(self, "k8s", value)

    @_builtins.property
    @pulumi.getter(name="k8sAggregator")
    def k8s_aggregator(self) -> pulumi.Input['CertificateArgs']:
        return pulumi.get(self, "k8s_aggregator")

    @k8s_aggregator.setter
    def k8s_aggregator(self, value: pulumi.Input['CertificateArgs']):
        pulumi.set(self, "k8s_aggregator", value)

    @_builtins.property
    @pulumi.getter(name="k8sServiceaccount")
    def k8s_serviceaccount(self) -> pulumi.Input['KeyArgs']:
        return pulumi.get(self, "k8s_serviceaccount")

    @k8s_serviceaccount.setter
    def k8s_serviceaccount(self, value: pulumi.Input['KeyArgs']):
        pulumi.set(self, "k8s_serviceaccount", value)

    @_builtins.property
    @pulumi.getter
    def os(self) -> pulumi.Input['CertificateArgs']:
        return pulumi.get(self, "os")

    @os.setter
    def os(self, value: pulumi.Input['CertificateArgs']):
        pulumi.set(self, "os", value)


if not MYPY:
    class CertificateArgsDict(TypedDict):
        """
        A Machine Secrets Certificate
        """
        cert: pulumi.Input[_builtins.str]
        """
        Certificate
        """
        key: pulumi.Input[_builtins.str]
        """
        Private Key
        """
elif False:
    CertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str]):
        """
        A Machine Secrets Certificate
        :param pulumi.Input[_builtins.str] cert: Certificate
        :param pulumi.Input[_builtins.str] key: Private Key
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Private Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ClientConfigurationArgsDict(TypedDict):
        """
        A Client Configuration
        """
        ca_certificate: pulumi.Input[_builtins.str]
        """
        The client CA certificate
        """
        client_certificate: pulumi.Input[_builtins.str]
        """
        The client certificate
        """
        client_key: pulumi.Input[_builtins.str]
        """
        The client private key
        """
elif False:
    ClientConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientConfigurationArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[_builtins.str],
                 client_certificate: pulumi.Input[_builtins.str],
                 client_key: pulumi.Input[_builtins.str]):
        """
        A Client Configuration
        :param pulumi.Input[_builtins.str] ca_certificate: The client CA certificate
        :param pulumi.Input[_builtins.str] client_certificate: The client certificate
        :param pulumi.Input[_builtins.str] client_key: The client private key
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        The client CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        The client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> pulumi.Input[_builtins.str]:
        """
        The client private key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_key", value)


if not MYPY:
    class ClusterArgsDict(TypedDict):
        """
        A Machine Secrets Cluster Info
        """
        id: _builtins.str
        """
        Certificate
        """
        secret: _builtins.str
        """
        Private Key
        """
elif False:
    ClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 secret: _builtins.str):
        """
        A Machine Secrets Cluster Info
        :param _builtins.str id: Certificate
        :param _builtins.str secret: Private Key
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Certificate
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Private Key
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: _builtins.str):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ClusterArgsDict(TypedDict):
        """
        A Machine Secrets Cluster Info
        """
        id: pulumi.Input[_builtins.str]
        """
        Certificate
        """
        secret: pulumi.Input[_builtins.str]
        """
        Private Key
        """
elif False:
    ClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str]):
        """
        A Machine Secrets Cluster Info
        :param pulumi.Input[_builtins.str] id: Certificate
        :param pulumi.Input[_builtins.str] secret: Private Key
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        Private Key
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class KeyArgsDict(TypedDict):
        """
        A Machine Secrets Private Key
        """
        key: _builtins.str
        """
        Private Key
        """
elif False:
    KeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyArgs:
    def __init__(__self__, *,
                 key: _builtins.str):
        """
        A Machine Secrets Private Key
        :param _builtins.str key: Private Key
        """
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Private Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)


if not MYPY:
    class KeyArgsDict(TypedDict):
        """
        A Machine Secrets Private Key
        """
        key: pulumi.Input[_builtins.str]
        """
        Private Key
        """
elif False:
    KeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str]):
        """
        A Machine Secrets Private Key
        :param pulumi.Input[_builtins.str] key: Private Key
        """
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Private Key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class KubernetesSecretsArgsDict(TypedDict):
        """
        A Machine Secrets Bootstrap data
        """
        bootstrap_token: _builtins.str
        """
        The bootstrap token for the talos kubernetes cluster
        """
        secretbox_encryption_secret: _builtins.str
        """
        The secretbox encryption secret for the talos kubernetes cluster
        """
        aescbc_encryption_secret: NotRequired[_builtins.str]
        """
        The aescbc encryption secret for the talos kubernetes cluster
        """
elif False:
    KubernetesSecretsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesSecretsArgs:
    def __init__(__self__, *,
                 bootstrap_token: _builtins.str,
                 secretbox_encryption_secret: _builtins.str,
                 aescbc_encryption_secret: Optional[_builtins.str] = None):
        """
        A Machine Secrets Bootstrap data
        :param _builtins.str bootstrap_token: The bootstrap token for the talos kubernetes cluster
        :param _builtins.str secretbox_encryption_secret: The secretbox encryption secret for the talos kubernetes cluster
        :param _builtins.str aescbc_encryption_secret: The aescbc encryption secret for the talos kubernetes cluster
        """
        pulumi.set(__self__, "bootstrap_token", bootstrap_token)
        pulumi.set(__self__, "secretbox_encryption_secret", secretbox_encryption_secret)
        if aescbc_encryption_secret is not None:
            pulumi.set(__self__, "aescbc_encryption_secret", aescbc_encryption_secret)

    @_builtins.property
    @pulumi.getter(name="bootstrapToken")
    def bootstrap_token(self) -> _builtins.str:
        """
        The bootstrap token for the talos kubernetes cluster
        """
        return pulumi.get(self, "bootstrap_token")

    @bootstrap_token.setter
    def bootstrap_token(self, value: _builtins.str):
        pulumi.set(self, "bootstrap_token", value)

    @_builtins.property
    @pulumi.getter(name="secretboxEncryptionSecret")
    def secretbox_encryption_secret(self) -> _builtins.str:
        """
        The secretbox encryption secret for the talos kubernetes cluster
        """
        return pulumi.get(self, "secretbox_encryption_secret")

    @secretbox_encryption_secret.setter
    def secretbox_encryption_secret(self, value: _builtins.str):
        pulumi.set(self, "secretbox_encryption_secret", value)

    @_builtins.property
    @pulumi.getter(name="aescbcEncryptionSecret")
    def aescbc_encryption_secret(self) -> Optional[_builtins.str]:
        """
        The aescbc encryption secret for the talos kubernetes cluster
        """
        return pulumi.get(self, "aescbc_encryption_secret")

    @aescbc_encryption_secret.setter
    def aescbc_encryption_secret(self, value: Optional[_builtins.str]):
        pulumi.set(self, "aescbc_encryption_secret", value)


if not MYPY:
    class KubernetesSecretsArgsDict(TypedDict):
        """
        A Machine Secrets Bootstrap data
        """
        bootstrap_token: pulumi.Input[_builtins.str]
        """
        The bootstrap token for the talos kubernetes cluster
        """
        secretbox_encryption_secret: pulumi.Input[_builtins.str]
        """
        The secretbox encryption secret for the talos kubernetes cluster
        """
        aescbc_encryption_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aescbc encryption secret for the talos kubernetes cluster
        """
elif False:
    KubernetesSecretsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesSecretsArgs:
    def __init__(__self__, *,
                 bootstrap_token: pulumi.Input[_builtins.str],
                 secretbox_encryption_secret: pulumi.Input[_builtins.str],
                 aescbc_encryption_secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A Machine Secrets Bootstrap data
        :param pulumi.Input[_builtins.str] bootstrap_token: The bootstrap token for the talos kubernetes cluster
        :param pulumi.Input[_builtins.str] secretbox_encryption_secret: The secretbox encryption secret for the talos kubernetes cluster
        :param pulumi.Input[_builtins.str] aescbc_encryption_secret: The aescbc encryption secret for the talos kubernetes cluster
        """
        pulumi.set(__self__, "bootstrap_token", bootstrap_token)
        pulumi.set(__self__, "secretbox_encryption_secret", secretbox_encryption_secret)
        if aescbc_encryption_secret is not None:
            pulumi.set(__self__, "aescbc_encryption_secret", aescbc_encryption_secret)

    @_builtins.property
    @pulumi.getter(name="bootstrapToken")
    def bootstrap_token(self) -> pulumi.Input[_builtins.str]:
        """
        The bootstrap token for the talos kubernetes cluster
        """
        return pulumi.get(self, "bootstrap_token")

    @bootstrap_token.setter
    def bootstrap_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bootstrap_token", value)

    @_builtins.property
    @pulumi.getter(name="secretboxEncryptionSecret")
    def secretbox_encryption_secret(self) -> pulumi.Input[_builtins.str]:
        """
        The secretbox encryption secret for the talos kubernetes cluster
        """
        return pulumi.get(self, "secretbox_encryption_secret")

    @secretbox_encryption_secret.setter
    def secretbox_encryption_secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secretbox_encryption_secret", value)

    @_builtins.property
    @pulumi.getter(name="aescbcEncryptionSecret")
    def aescbc_encryption_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aescbc encryption secret for the talos kubernetes cluster
        """
        return pulumi.get(self, "aescbc_encryption_secret")

    @aescbc_encryption_secret.setter
    def aescbc_encryption_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "aescbc_encryption_secret", value)


if not MYPY:
    class MachineSecretsArgsDict(TypedDict):
        """
        A complete Machine Secrets configuration
        """
        certs: 'CertificatesArgsDict'
        cluster: 'ClusterArgsDict'
        secrets: 'KubernetesSecretsArgsDict'
        trustdinfo: 'TrustdInfoArgsDict'
elif False:
    MachineSecretsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineSecretsArgs:
    def __init__(__self__, *,
                 certs: 'CertificatesArgs',
                 cluster: 'ClusterArgs',
                 secrets: 'KubernetesSecretsArgs',
                 trustdinfo: 'TrustdInfoArgs'):
        """
        A complete Machine Secrets configuration
        """
        pulumi.set(__self__, "certs", certs)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "secrets", secrets)
        pulumi.set(__self__, "trustdinfo", trustdinfo)

    @_builtins.property
    @pulumi.getter
    def certs(self) -> 'CertificatesArgs':
        return pulumi.get(self, "certs")

    @certs.setter
    def certs(self, value: 'CertificatesArgs'):
        pulumi.set(self, "certs", value)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> 'ClusterArgs':
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: 'ClusterArgs'):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> 'KubernetesSecretsArgs':
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: 'KubernetesSecretsArgs'):
        pulumi.set(self, "secrets", value)

    @_builtins.property
    @pulumi.getter
    def trustdinfo(self) -> 'TrustdInfoArgs':
        return pulumi.get(self, "trustdinfo")

    @trustdinfo.setter
    def trustdinfo(self, value: 'TrustdInfoArgs'):
        pulumi.set(self, "trustdinfo", value)


if not MYPY:
    class MachineSecretsArgsDict(TypedDict):
        """
        A complete Machine Secrets configuration
        """
        certs: pulumi.Input['CertificatesArgsDict']
        cluster: pulumi.Input['ClusterArgsDict']
        secrets: pulumi.Input['KubernetesSecretsArgsDict']
        trustdinfo: pulumi.Input['TrustdInfoArgsDict']
elif False:
    MachineSecretsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineSecretsArgs:
    def __init__(__self__, *,
                 certs: pulumi.Input['CertificatesArgs'],
                 cluster: pulumi.Input['ClusterArgs'],
                 secrets: pulumi.Input['KubernetesSecretsArgs'],
                 trustdinfo: pulumi.Input['TrustdInfoArgs']):
        """
        A complete Machine Secrets configuration
        """
        pulumi.set(__self__, "certs", certs)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "secrets", secrets)
        pulumi.set(__self__, "trustdinfo", trustdinfo)

    @_builtins.property
    @pulumi.getter
    def certs(self) -> pulumi.Input['CertificatesArgs']:
        return pulumi.get(self, "certs")

    @certs.setter
    def certs(self, value: pulumi.Input['CertificatesArgs']):
        pulumi.set(self, "certs", value)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> pulumi.Input['ClusterArgs']:
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input['ClusterArgs']):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> pulumi.Input['KubernetesSecretsArgs']:
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: pulumi.Input['KubernetesSecretsArgs']):
        pulumi.set(self, "secrets", value)

    @_builtins.property
    @pulumi.getter
    def trustdinfo(self) -> pulumi.Input['TrustdInfoArgs']:
        return pulumi.get(self, "trustdinfo")

    @trustdinfo.setter
    def trustdinfo(self, value: pulumi.Input['TrustdInfoArgs']):
        pulumi.set(self, "trustdinfo", value)


if not MYPY:
    class TrustdInfoArgsDict(TypedDict):
        """
        A Machine Secrets Trust daemon info
        """
        token: _builtins.str
        """
        The trustd token for the talos kubernetes cluster
        """
elif False:
    TrustdInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustdInfoArgs:
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        A Machine Secrets Trust daemon info
        :param _builtins.str token: The trustd token for the talos kubernetes cluster
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The trustd token for the talos kubernetes cluster
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: _builtins.str):
        pulumi.set(self, "token", value)


if not MYPY:
    class TrustdInfoArgsDict(TypedDict):
        """
        A Machine Secrets Trust daemon info
        """
        token: pulumi.Input[_builtins.str]
        """
        The trustd token for the talos kubernetes cluster
        """
elif False:
    TrustdInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrustdInfoArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[_builtins.str]):
        """
        A Machine Secrets Trust daemon info
        :param pulumi.Input[_builtins.str] token: The trustd token for the talos kubernetes cluster
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The trustd token for the talos kubernetes cluster
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class GetDisksClientConfigurationArgsDict(TypedDict):
        ca_certificate: _builtins.str
        """
        The client CA certificate
        """
        client_certificate: _builtins.str
        """
        The client certificate
        """
        client_key: _builtins.str
        """
        The client key
        """
elif False:
    GetDisksClientConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDisksClientConfigurationArgs:
    def __init__(__self__, *,
                 ca_certificate: _builtins.str,
                 client_certificate: _builtins.str,
                 client_key: _builtins.str):
        """
        :param _builtins.str ca_certificate: The client CA certificate
        :param _builtins.str client_certificate: The client certificate
        :param _builtins.str client_key: The client key
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> _builtins.str:
        """
        The client CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: _builtins.str):
        pulumi.set(self, "ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> _builtins.str:
        """
        The client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: _builtins.str):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> _builtins.str:
        """
        The client key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: _builtins.str):
        pulumi.set(self, "client_key", value)


if not MYPY:
    class GetDisksTimeoutsArgsDict(TypedDict):
        read: NotRequired[_builtins.str]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
elif False:
    GetDisksTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDisksTimeoutsArgs:
    def __init__(__self__, *,
                 read: Optional[_builtins.str] = None):
        """
        :param _builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if read is not None:
            pulumi.set(__self__, "read", read)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[_builtins.str]):
        pulumi.set(self, "read", value)


